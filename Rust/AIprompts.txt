"get path to awesomeface.png"
fn main() {
    let current_dir = env::current_dir().expect("Failed to get current directory");
    let image_path = current_dir.join("awesomeface.png");
    
    // Use the image_path variable in your code
    // ...
}
use std::env;

"how to add rust crate to my program"
[package]
name = "my_project"
version = "0.1.0"
edition = "2018"

[dependencies]
image = "0.23.14"

"create function to save image"
use image::GenericImageView;

fn save_image(image: &DynamicImage, path: &str) {
    image
        .save(path)
        .expect("Failed to save image");
}

"How do i pass parameters to main function?"
fn main() {
    let args: Vec<String> = std::env::args().collect();
    println!("{:?}", args);
}

"check size of args"
if args.len() < 3 {
    panic!("Not enough arguments. Expected path to image1, path to image2, and operation (r, m, b).");
}

"use args[0] in match statement"
let mode = &args[1];
match mode.as_str() {
    "r" => {}, //removal
    "m" => {}, //merge
    "b" => {}, //blur
    _ => panic!("Invalid operation. Expected 'r', 'm', or 'b'."),
}

"how to print variable inside of println!"
let num_args = args.len();
println!("Number of arguments passed: {}", num_args);

"how to get path of 2 pictures in images folder"
"what if i dont know the names of the images"
use std::fs;

fn main() {
    let paths = fs::read_dir("./images").unwrap();

    let mut image_paths = Vec::new();

    for path in paths {
        let path_str = path.unwrap().path().display().to_string();
        if path_str.ends_with(".png") {
            image_paths.push(path_str);
        }
    }

    println!("{:?}", image_paths);
}

"how to change rgba pixel data"
let pixel = img.get_pixel(x, y);
let mut new_pixel = pixel.to_rgba();
new_pixel[0] = 255; // Set the red channel to its maximum value
img.put_pixel(x, y, image::Rgba(new_pixel));

"iterate throught all pixel channels"
for (x, y, pixel) in img.enumerate_pixels_mut() {
    for channel in pixel.channels_mut() {
        // Manipulate channel here
    }
}

"code for merging two images based on ratio of two images"
for (x, y, pixel) in img.enumerate_pixels() {
    let mut pixel1 = *pixel;
    let mut pixel2 = *img2.get_pixel(x, y);
    for (channel1, channel2) in pixel1.channels_mut().iter_mut().zip(pixel2.channels().iter()) {
        *channel1 = ((*channel1 as f32 * ratio1) + (*channel2 as f32 * ratio2)) as u8;
    }
    img.put_pixel(x, y, pixel1);
}

"How can I state that my variable mergedPixel represents Rgba"
let mut mergedPixel: image::Rgba<u8> = image::Rgba([0, 0, 0, 0]);
