"get path to awesomeface.png"
fn main() {
    let current_dir = env::current_dir().expect("Failed to get current directory");
    let image_path = current_dir.join("awesomeface.png");
    
    // Use the image_path variable in your code
    // ...
}
use std::env;

"how to add rust crate to my program"
[package]
name = "my_project"
version = "0.1.0"
edition = "2018"

[dependencies]
image = "0.23.14"

"create function to save image"
use image::GenericImageView;

fn save_image(image: &DynamicImage, path: &str) {
    image
        .save(path)
        .expect("Failed to save image");
}

"How do i pass parameters to main function?"
fn main() {
    let args: Vec<String> = std::env::args().collect();
    println!("{:?}", args);
}

"check size of args"
if args.len() < 3 {
    panic!("Not enough arguments. Expected path to image1, path to image2, and operation (r, m, b).");
}

"use args[0] in match statement"
let mode = &args[1];
match mode.as_str() {
    "r" => {}, //removal
    "m" => {}, //merge
    "b" => {}, //blur
    _ => panic!("Invalid operation. Expected 'r', 'm', or 'b'."),
}

"how to print variable inside of println!"
let num_args = args.len();
println!("Number of arguments passed: {}", num_args);

"how to get path of 2 pictures in images folder"
"what if i dont know the names of the images"
use std::fs;

fn main() {
    let paths = fs::read_dir("./images").unwrap();

    let mut image_paths = Vec::new();

    for path in paths {
        let path_str = path.unwrap().path().display().to_string();
        if path_str.ends_with(".png") {
            image_paths.push(path_str);
        }
    }

    println!("{:?}", image_paths);
}

"how to change rgba pixel data"
let pixel = img.get_pixel(x, y);
let mut new_pixel = pixel.to_rgba();
new_pixel[0] = 255; // Set the red channel to its maximum value
img.put_pixel(x, y, image::Rgba(new_pixel));

"iterate throught all pixel channels"
for (x, y, pixel) in img.enumerate_pixels_mut() {
    for channel in pixel.channels_mut() {
        // Manipulate channel here
    }
}

"code for merging two images based on ratio of two images"
for (x, y, pixel) in img.enumerate_pixels() {
    let mut pixel1 = *pixel;
    let mut pixel2 = *img2.get_pixel(x, y);
    for (channel1, channel2) in pixel1.channels_mut().iter_mut().zip(pixel2.channels().iter()) {
        *channel1 = ((*channel1 as f32 * ratio1) + (*channel2 as f32 * ratio2)) as u8;
    }
    img.put_pixel(x, y, pixel1);
}

"How can I state that my variable mergedPixel represents Rgba"
let mut mergedPixel: image::Rgba<u8> = image::Rgba([0, 0, 0, 0]);

"iterate by every third args"
for arg in args.iter().step_by(3) {
    // Use arg here
}

"How to check if arg is out of bound"
if let Some(arg) = args.get(index) {
    // Use arg here
} else {
    // Handle the case where the index is out of bounds
}

"In one loop get args[i],args[i+1],args[i+2]"
for i in (1..args.len()).step_by(3) {
    if let Some(arg1) = args.get(i) {
        if let Some(arg2) = args.get(i + 1) {
            if let Some(arg3) = args.get(i + 2) {
                // Use arg1, arg2, and arg3 here
            } else {
                // Handle the case where i + 2 is out of bounds
            }
        } else {
            // Handle the case where i + 1 is out of bounds
        }
    } else {
        // Handle the case where i is out of bounds
    }
}

"s" =>{//square
    let x = arg2.parse::<u32>().unwrap();
    let y = arg3.parse::<u32>().unwrap();
    for i in x..(x+100){
        for j in y..(y+100){
            imgbuf.put_pixel(i, j, image::Rgba([0, 0, 0, 0]));
        }
    }
    imgbuf.save("out/out.png").unwrap();

},
"c" =>{//circle
    let x = arg2.parse::<u32>().unwrap();
    let y = arg3.parse::<u32>().unwrap();
    for i in x..(x+100){
        for j in y..(y+100){
            if (i-x)*(i-x) + (j-y)*(j-y) <= 10000{
                imgbuf.put_pixel(i, j, image::Rgba([0, 0, 0, 0]));
            }
        }
    }
    imgbuf.save("out/out.png").unwrap();

},
_=> panic!("Invalid shape. Expected 's' or 'c'."),

"get total time of each loop"
for _ in 0..12 {
    let start = std::time::Instant::now();
    // Your action here
    let end = std::time::Instant::now();
    let totalTime = end.duration_since(start);
    println!("Time elapsed: {:?}", totalTime);
}

"sum it up for all 12 iterations"
let mut total_time = std::time::Duration::new(0, 0);
for _ in 0..12 {
    let start = std::time::Instant::now();
    // Your action here
    let end = std::time::Instant::now();
    let elapsed_time = end.duration_since(start);
    total_time += elapsed_time;
}
println!("Total time elapsed: {:?}", total_time);